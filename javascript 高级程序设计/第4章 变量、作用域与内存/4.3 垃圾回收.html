<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>垃圾回收</title>
</head>

<body>

</body>
<script>
    // JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C 和 C++等
    // 语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下
    // 了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再
    // 使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执
    // 行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内 
    // 存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。
        // 我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或
        // 堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部
        // 变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时
        // 候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收
        // 内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的
        // 标记策略：标记清理和引用计数。


    // 时常采用的垃圾回收策略有 标记清理 以及 引用计数
    // 而在引用计数中存在一种缺漏，那便是循环引用问题
    // 例子如下
    let element = document.getElementById('222');
    let myobject = new Object();
    myObject.element = element;
    element.someObject = myObject;
    //     这个例子在一个 DOM 对象（element）和一个原生 JavaScript 对象（myObject）之间制造了循环
    // 引用。myObject 变量有一个名为 element 的属性指向 DOM 对象 element，而 element 对象有一个
    // someObject 属性指回 myObject 对象。由于存在循环引用，因此 DOM 元素的内存永远不会被回收，
    // 即使它已经被从页面上删除了也是如此。
    //     为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之
    // 间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：
    myObject.element = null;
    element.someObject = null;
    // 把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，
    // 这些值就会被删除，内存也会被回收。
    // 为了补救这一点，IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象，这同时也避免了由于存在两
    // 套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。

</script>

</html>