<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    /*
        除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。ECMAScript 数组跟其他编程语言
    的数组有很大区别。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言
    不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素
    是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而
    自动增长。
    */

    // 创建数组

    // let colors =  new Array(params);// ==> 其中的params 代表数值时，则代表着该数组会创建params个空元素，当为字符串串时则会创建只
    // 包含该字符串的数组
    // let colors = new Array(3);
    // console.log(colors);
    // let colors1 = new Array("lalal");
    // console.log(colors1);

    /*
        Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性
    和可索引元素的结构。这种方式可用于很多场合：
    */
    // // 字符串會拆分為單字符數組 p164
    // console.log(Array.from("Chensiyuan"));
    // // 可以使用 from()将集合和映射转换为一个新数组
    // const m = new Map().set(1, 2)
    //     .set(3, 4);
    // const s = new Set().add(1)
    //     .add(2)
    //     .add(3)
    //     .add(4);
    // console.log(Array.from(m)); // [[1, 2], [3, 4]]
    // console.log(Array.from(s)); // [1, 2, 3, 4]

    // // Array.from()对现有数组执行浅复制
    // const a1 = [1, 2, 3, 4];
    // const a2 = Array.from(a1);
    // console.log(a1);
    // // alert(a1 == a2);

    // // 可以使用任何可迭代对象
    // const iter = {
    //     *[Symbol.iterator]() {
    //         yield 1;
    //         yield 2;
    //         yield 3;
    //         yield 4;
    //     }
    // };
    // console.log(Array.from(iter)); // [1, 2, 3, 4]

    // var myIterable = {}
    // myIterable[Symbol.iterator] = function* () {
    //     yield 1;
    //     yield 2;
    //     yield 3;
    // };
    // console.log([...myIterable]) // [1, 2, 3]

    // // arguments对象 可以轻松地转换为数组
    // function getArgsArray() {
    //     return Array.from(arguments);
    // }
    // console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]

    // // from()也能转换带有必要属性的自定义对象
    //     const arraylikeObject = {
    //         0: 1,
    //         1: 2,
    //         2: 3,
    //         3: 4,
    //         length : 4,
    //     };

    // // 
    // console.log(Array.from(arraylikeObject));

    /*
            Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像
        调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函
        数中 this 的值。但这个重写的 this 值在箭头函数中不适用。
     */
    // const a1 = [1, 2, 3, 4];
    // const a2 = Array.from(a1, x => x ** 2);
    // const a3 = Array.from(a1, function (x) { return x ** this.exponent }, { exponent: 2 });
    // console.log(a2);
    // console.log(a3);


    /*
            Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype.
        slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：
    */

    // console.log(Array.of(1,2,3,4,));
    // console.log(Array.of(undefined));

    // 数组空位

    /*
        使用数组字面量初始化数组时,可以使用一串逗号来创建空位(hole)。ECMAScript会在逗号之间相应索引位置的值当作为空位。
    */
    // const options = [,,,,,]; //几个逗号 几个空位
    // console.log(options.length);
    // console.log(options);

    /*
        ES6 新增的方法和迭代器与早期 ECMAScript 版本中存在的方法行为不同。ES6 新增方法普遍将这
    些空位当成存在的元素，只不过值为 undefined：
    */
    // const options = [1,,,,5];
    // for(const option of options){
    //     console.log(option === undefined);
    // }

    // const a = Array.from([,,,]);
    // for(const val of a ){
    //     alert(val === undefined);    
    // }
    // alert(Array.of(...[,,,]));  //==> '"'

    // for (const [index, value] of options.entries()) {
    //     alert(value);
    // }

    // const options = [1, , , , 5];
    // // map()会跳过空位置
    // console.log(options.map(() => 6)); // [6, undefined, undefined, undefined, 6]
    // // join()视空位置为空字符串
    // console.log(options.join('-')); // "1----5" 


    //数组索引
    // 其中大部分是与C的数组索引是相似的。具体的区别体现在数组长度方面
    // 在创建了的数组中，进行删除元素，元素会被undefined替代,打印时则会隐藏。
    // let colors = ["green","blue","black"];
    // colors.length = 2;
    // console.log(colors);
    // console.log(colors[2]);

    // 通过赋值的方法可以添加数组内部元素，用于填充末位。
    // colors[colors.length] = "black"; // 添加一种颜色（位置 3）
    // colors[colors.length] = "brown"; // 再添加一种颜色（位置 4）
    // console.log(colors);

    /*
        数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。
        如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。
    */

    // 检测数组
    /*
        一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作
        用域）的情况下，使用 instanceof 操作符就足矣：
        if (value instanceof Array){
        // 操作数组
        }
        使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两
        个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传
        给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。
            为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是
        否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：
        if (Array.isArray(value)){
            // 操作数组
        } 
    */

</script>

</html>