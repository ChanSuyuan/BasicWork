<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // Map 是 ES6 新添加的一种集合类型，在Map之前，在Javascript中实现 键/值 式存储可以使用Object来高效地完成。
    // ===================================基本API
    // 使用new 关键字 和Map构造函数可以创建一个空映射。
    // const m = new Map();
    // /* 
    //     如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数
    // 组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：
    // */
    // // 使用嵌套数组初始化映射
    // const m1 = new Map([
    //     ["key1","val1"],
    //     ["key2","val2"],
    //     ["key3","val3"],
    // ]);
    // console.log(m1.size);//3
    // // 使用自定义迭代器初始化映射、
    // const m2 = new Map({
    //     [Symbol.iterator]:function*(){
    //         yield ["key1","val1"];
    //         yield ["key2","val2"];
    //         yield ["key3","val3"];
    //     }
    // });
    // console.log(m2.size);//3

    // // 映射期待的键值对，无论是否提供
    // const m3 = new Map([[]]);
    // console.log(m3.has(undefined));//true
    // console.log(m3.get(undefined));//undefined
    // 初始化后可以使用set()添加键值对。除此之外，可以通过has()和get()进行查询，可以通过size属性获取映射中的键值对的数量。还可以使用
    //  delete()和clear()进行删除操作。
    // const m = new Map();
    // console.log(m.has("FirstName"));//false
    // console.log(m.get("FirstName"));//undefined
    // console.log(m.size);//0

    // m.set("FirstName", "Matt").set("LastName", "Nicloa");
    // console.log(m.has("FirstName"));//true
    // console.log(m.get("FirstName"));//Matt
    // console.log(m.size);//2

    // m.delete("FirstName");//仅仅只删除 "FirstName"这一个键值对
    // console.log(m.has("FirstName"));//false
    // console.log(m.get("FirstName"));//undefined
    // console.log(m.size);//1

    // m.clear();//清楚该映射实例的所有键值对
    // console.log(m.has("FirstName"));//false
    // console.log(m.get("FirstName"));//false
    // console.log(m.size);//0

    // set()方法可以返回映射实例，因此可以把多个操作连缀起来，包括初始声明
    // const m  = new Map().set("FirstName","Chen");

    // 与Object只能使用数值、字符串或符号作为键不同，Map可以使用任何JavaScript数据类型为键。Map内部使用SameValueZero比较操作。
    // 基本上相当于使用严格对象相等的标准来检查键的匹配性。与 Object 类似，映射的值是没有限制的。
    // const m = new Map();
    // const functionKey = function () { };
    // const symbolKey = Symbol();
    // const objectKey = new Object();

    // m.set(functionKey, "functionValue").set(symbolKey, "symbolValue").set(objectKey, "objectValue");

    // console.log(m.get(functionKey)); // functionValue
    // console.log(m.get(symbolKey)); // symbolValue
    // console.log(m.get(objectKey)); // objectValue 

    // // SameValueZero 比较意味着独立实例不冲突
    // console.log(m.get(function () { })); // undefined

    /*
        与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时
    仍然保持不变：
    */
    // const m = new Map();
    // const objKey = {},
    //     objVal = {},
    //     arrKey = [],
    //     arrVal = [];

    // m.set(objKey, objVal);
    // m.set(arrKey, arrVal);
    // objKey.foo = "foo";
    // objVal.bar = "bar";
    // arrKey.push("foo");
    // arrVal.push("bar");
    // console.log(m.get(objKey)); // {bar: "bar"}
    // console.log(m.get(arrKey)); // ["bar"]
    // // SameValueZero 比较也可能导致意想不到的冲突：
    // const m = new Map();
    // const a = 0 / "", // NaN
    //     b = 0 / "", // NaN
    //     pz = +0,
    //     nz = -0;
    // console.log(a === b); //false
    // console.log(pz === nz); //true
    // m.set(a, "foo");
    // m.set(pz, "bar");
    // console.log(m.get(b)); // foo
    // console.log(m.get(nz)); // bar

    /* 
        SameValueZero 是 ECMAScript 规范新增的相等性比较算法。关于 ECMAScript 的相
    等性比较，可以参考 MDN 文档中的文章“Equality Comparisons and Sameness”。
    */
    
    // 顺序与迭代
    /* 
        与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执
    行迭代操作。映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。
    可以通过 entries()方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器：
    */
   
    
</script>

</html>